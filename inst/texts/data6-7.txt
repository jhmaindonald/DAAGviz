6
Data Objects and Functions

                                                                       Data objects and functions are
Dierent types of data objects:                                         two of several types of objects
                                                                       (others include model objects,
  Vectors    These collect together elements of the same mode.         formulae, and expressions) that are
             (Possible modes are "logical", "integer", "numeric",      available in R. Users can create
             "complex", "character" and "raw")                         and work with such objects in a
                                                                       user workspace. All can, if the
  Factors    Factors identify category levels in categorical data.     occasion demands, be treated as
             Modeling functions know how to represent factors.         data!
             (Factors do not quite manage to be vectors! Why?)
  Data       A list of columns ­ same length; modes may dier.
  frame      Data frames are a device for organizing data.
  Lists      Lists group together an arbitrary set of objects
             (Lists are recursive; elements of lists are lists.)
  NAs        Use is.na() to check for NAs.

    We start this chapter by noting data objects that may appear as
columns of a data frame.


6.1       Column Data Objects ­ Vectors and Factors
Column objects are vectors1 or factors. Factors do not quite qualify   1
                                                                         Strictly, the vectors that we
as vectors. Column objects can be gathered together to become          discuss here are atomic vectors.
columns in a data frame.                                               Their elements are not, as happens
                                                                       with lists, wrappers for other
                                                                       language objects.
6.1.1     Vectors
Examples of vectors are                                                Common vector modes are logical,
                                                                       numeric and character. The 4 lines
c (2 ,3 ,5 ,2 ,7 ,1)                                                   of code create vectors that are, in
3 : 1 0 # The numbers 3, 4,.. , 10                                     order: numeric, numeric, logical,
c (TRUE , FALSE , FALSE , FALSE , TRUE , TRUE , FALSE )                character.
c ( " f i g " , " mango " , " a p p l e " , " p r u n e " )
54    data analysis, graphics, and visualisation using r

      Use mode() to show the storage mode of an object. For exam-
ple
x      c (TRUE , FALSE , FALSE , FALSE , TRUE , TRUE , FALSE )
mode ( x )

[1] " logical "

    The missing value symbol is NA. Subsection 6.1.3 will discuss
issues that arise when one or more vector elements is an NA.

Subsets of Vectors
There are four common ways to extract subsets of vectors.
     1. Specify the subscripts of elements that are to be extracted,
e.g.
x     c (3 ,11 ,8 ,15 ,12)           # Assign to x the values
x[c (2 ,4)]                          # Extract elements 2 and 4

[1] 11 15

      Negative numbers may be used to omit elements:2                        2
                                                                              Mixing of positive and negative
> x <- c(3,11,8,15,12)                                                       subscripts is not allowed.
> x[-c(2,3)]
[1] 3 15 12

    2. Specify a vector of logical values. The elements that are             Arithmetic relations that may
extracted are those for which the logical value is TRUE. Thus suppose        be used for extraction of subsets
we want to extract values of x that are greater than 10.                     are >=, ==, != and %in%. The first
                                                                             four compare magnitudes, ==
x >10      # Values are logical (TRUE or FALSE)                              tests for equality, != tests for
                                                                             inequality, and %in% tests whether
[1] FALSE        TRUE FALSE           TRUE      TRUE
                                                                             any element matches.

x [ x > 10]

[1] 11 15 12

" J o h n " %i n% c ( " J e f f " , " Alan " , " J o h n " )

[1] TRUE

    3. Where elements have names, these can be used to extract
elements:
altitude           c ( C a m b a r v i l l e =800 , B e l l b i r d =300 ,
                       " A l l y n R i v e r " =300 ,
                       " Whian Whian " =400 ,
                       B y r a n g e r y =200 , C o n o n d a l e =400 ,
                       B u l b u r i n =600)
##
## Names can be used to extract elements
a l t i t u d e [ c ( " Cambarville " , " Bellbird " )]
                                                                                    data objects and functions          55


Cambarville               Bellbird
        800                    300

    4. Use subset(), with the vector as the first argument, and a
logical statement that identifies the elements to be extracted as the
second argument. For example:
s u b s e t ( a l t i t u d e , a l t i t u d e >400)

Cambarville               Bulburin
        800                    600



6.1.2      Factors
                                                                                    Factors are an economical way
Factors are column objects whose elements are integer values 1, 2,                  to store vectors of repetitive text
. . . , k, where k is the number of levels. They are distinguished from             strings. By default, when a vector
integer vectors by having the class factor and a levels attribute.                  of text strings becomes a column
        For example, create a character vector fruit, thus:                         in a data frame, it is incorporated
                                                                                    as a factor.
fruit          c ( " f i g " , " mango " , " a p p l e " , " plum " , " f i g " )

    This might equally well be stored as a factor, thus:
fruitfac             factor ( fruit )

   Internally, the factor is stored as the integer vector 2, 3, 1, 4, 2.            Thus 1 is interpreted as "apple";
These numbers are interpreted according to the attributes table:                    2:"fig"; 3:"mango"; 4:"plum".

         1              2            3               4
      "apple"         "fig"       "mango"         "plum"
By default, the levels are taken in alphanumeric order.
     The function factor(), with the levels argument specified,
can be used both to specify the order of levels when the factor is
created, or to make a later change to the order.3 For example, the                  3
                                                                                      Where counts are tabulated by
following orders levels according to stated glycemic index:                         factor level, or lattice or other
                                                                                    graphs have one panel per factor
glycInd      c ( a p p l e =40 , f i g =35 , mango =55 , plum =25)                  level, these are in order of the
## Take levels in order of stated glycInd index                                     levels.
fruitfac       factor ( fruit ,
                            l e v e l s =names ( s o r t ( g l y c I n d ) ) )
levels ( fruitfac )

[1] "plum"           "fig"         " apple" " mango"


unclass ( f r u i t f a c )      # Examine stored values

[1] 2 4 3 1 2
attr (," levels ")
[1] "plum" "fig"                   " apple" " mango"
56    data analysis, graphics, and visualisation using r                                          Mis-spelt name, example:
                                                                                                 trt
     Incorrect spelling of the level names generates missing values,                             c ( "A" , "A" , " C o n t r o l " )
                                                                                                 trtfac             factor ( trt ,
for the level that was mis-spelled. Use the labels argument if you                                   l e v e l s =c ( " c o n t r o l " , "A" ) )
wish to change the level names, but be careful to ensure that the                                table ( trtfac )
label names are in the correct order.
     In most places where the context seems to demand it, the integer                            trtfac
                                                                                                 control                   A
levels are translated into text strings, thus:                                                          0                  2
fruit           c ( " f i g " , " mango " , " a p p l e " , " plum " , " f i g " )
fruitfac              factor ( fruit )
f r u i t f a c == " f i g "

[1]     TRUE FALSE FALSE FALSE                     TRUE

    Section 10.3 has detailed examples of the use of factors in model
formulae.

Ordered factors
In addition to factors, note the existence of ordered factors, created
using the function ordered(). For ordered factors, the order of
levels implies a relational ordering. For example:
windowTint              o r d e r e d ( r e p ( c ( " l o " , " med " , " h i " ) , 2 ) ,
                                        l e v e l s =c ( " l o " , " med " , " h i " ) )
windowTint

[1] lo med hi lo med hi
Levels : lo < med < hi

sum ( w i n d o w T i n t > " l o " )

[1] 4



Subsetting of factors
Consider the factor fruitfac that was created earlier:
fruitfac             f a c t o r ( c ( " f i g " , " mango " , " a p p l e " , " plum " , " f i g " ) )
      We can remove elements with levels fig and plum thus:
ff2         f r u i t f a c [ ! f r u i t f a c %i n% c ( " f i g " , " plum " ) ]
ff2

[1] mango apple
Levels : apple fig mango plum

table ( ff2 )

ff2
apple        fig mango           plum
    1          0     1              0
                                                                           data objects and functions        57

    The levels fig and plum remain, but with the table showing 0           Note also:
values for these levels. Use the function droplevels() to remove           table ( droplevels ( ff2 ))
levels that are not present in the data:
droplevels ( ff2 )                                                         apple mango
                                                                               1     1
[1] mango apple
Levels : apple mango


Why is a factor not a vector?
Two factors that have dierent levels vectors are dierent types of          Vectors can be concatenated
object. Thus, formal concatenation of factors with dierent levels          (joined). Two or mare factors can
vectors is handled by first coercing both factors to integer vectors.      be sensibly concatenated only if
                                                                           they have identical levels vectors.
The integer vector that results is not, in most circumstances, mean-
ingful or useful.

6.1.3    Missing Values, Infinite Values and NaNs
Any arithmetic or logical operation with NA generates an NA. The           Failure to understand the rules for
consequences are more far-reaching than might be immediately               calculations with NAs can lead to
obvious. Use is.na() to test for a missing value:                          unwelcome surprises.

i s . n a ( c ( 1 , NA, 3 , 0 , NA) )
[1] FALSE       TRUE FALSE FALSE          TRUE

    An expression such as c(1, NA, 3, 0, NA) == NA returns a
vector of NAs, and cannot be used to test for missing values.
c ( 1 , NA, 3 , 0 , NA) == NA
[1] NA NA NA NA NA

     As the value is unknown, it might or might not be equal to 1, or
to another NA, or to 3, or to 0.
     Note that dierent functions handle NAs in dierent ways.               The modeling function lm()
Functions such as mean() and median() accept the argument                  accepts any of the arguments
na.rm=TRUE, which causes observations that have NAs to be ig-              na.action=na.omit (omit),
                                                                           na.action=na.exclude
nored. The plot() function omits NAs, infinities and NaNs. For use
                                                                           (omit NAs when fitting; replace
of lowess() to put a smooth curve through the plot, NAs must first         by NAs when fitted values and
be removed. By default, table() ignores NAs.                               residuals are calculated), and
     Problems with missing values are a common reason why calcu-           na.action=na.fail.
lations fail. Infinite values and NaNs are a further potential source of
di culty.

Inf and NaN
The expression 1/0 returns Inf. The expression log(0) returns              Note that sqrt(-1+0i) returns
-Inf, i.e., smaller than any real number. The expressions 0/0 and          sqrt(0+1i). R distinguishes be-
log(-1) both return NaN.                                                   tween -1, which is a real number,
                                                                           and -1+0i which is a complex
                                                                           number.
58    data analysis, graphics, and visualisation using r

NAs in subscripts?
It is best to ensure that NAs do not appear, when there is an assign-
ment, in subscript expressions on either side of the expression.


6.2      Data Frames
Data frames are lists of column objects. The requirement that all of         Distinguish data frames from
the column objects have the same length gives data frames a row by           matrices. Data frames whose el-
column rectangular structure.                                                ements all have the same mode
                                                                             (commonly, numeric) are in some
    The data frame travelbooks will feature in the subsequent
                                                                             contexts interchangeable with ma-
discussion. Look back to Section 2.4 to see how it can be entered.           trices, but that is not true in gen-
                                                                             eral. Matrices will be discussed
6.2.1     The subscript notation                                             further in Section 6.3.1.

One consequence of the way that data frames are structured is that
use of the subscript notation to extract a row from a data frame gives
a dierent data structure from use of the subscript notation to extract
a column. Specifically:

· travelbooks$volume (equivalent to travelbooks[,1] or
  travelbooks[,"volume"])) is a vector.

· Extraction of a row from a data frame, for example
  travelbooks["Canberra - The Guide", ] or
  travelbooks[6, ], yields a data frame, i.e., a special form of
  list. The syntax unlist(travelbooks[6, ]) can be used to
  turn such a list into a vector. All elements are coerced to a com-
  mon mode, in this case numeric. Thus the final element becomes
  1.0 (the code that is stored), rather than Guide which was the first
  level of the factor type.

6.2.2     Addition of columns to Data Frames

## Place the file in the working directory
## NB: DAAG must be installed
l i b r a r y (DAAG) # Attach the DAAG package
datafile ( " travelbooks " )

    The following adds new columns area (area of page),
and density (weight to volume ratio) to the data frame
travelbooks:
travelbooks $ area              with ( travelbooks , width * h e i g h t )
travelbooks $ density              with ( travelbooks ,
                                          w e i g h t / volume )
names ( t r a v e l b o o k s )  # Check column names
                                                                                     data objects and functions      59


[1] " thickness " " width"                     " height "              " weight "
[5] " volume "    "type"                       "area"                  " density "

6.2.3     Inclusion of character vectors in data frames
When data frames are created, whether by use of read.table()
or another such function to input data from a file, or by use of the
function data.frame() to join columns of data together into a data
frame, character vectors are converted into factors. Thus, the final
column (type) of travelbooks became, by default, a factor.4 To                       4
                                                                                      This assumes that the global
prevent such type conversions, specify stringsAsFactors=FALSE                        option stringsAsFactors is
in the call to read.table() or data.frame().                                         FALSE. To check, interrogate
                                                                                     options()$stringsAsFactors.

6.2.4     Factor columns data frame subsets
The data frame ais (DAAG) has physical charateristics of athletes
from ten dierent sports. The following shows the number of obser-
vations for each of the ten dierent sports:
with ( ais , t a b l e ( s p o r t ) )
sport
 B_Ball     Field                 Gym Netball                Row          Swim
T_400m
      25       19                    4           23            37
22       29
T_Sprnt Tennis               W_Polo
      15       11                17

     Figure 8.2.1 in Subsection 8.9 shows data for swimmers and
rowers only -- a restriction that keeps the graph reasonably sim-
ple. To limits the data to swimmers and rowers, at the same time
removing all levels except Row and Swim from the factor sport, do:
rowswim              w i t h ( a i s , s p o r t %i n% c ( "Row" , " Swim " ) )
aisRS            d r o p l e v e l s ( s u b s e t ( a i s , rowswim ) )
x t a b s (  s p o r t , d a t a =a i s R S )
sport
 Row Swim
  37   22

    Contrast the above with:
x t a b s (  s p o r t , d a t a = s u b s e t ( a i s , rowswim ) )
sport
 B_Ball         Field             Gym Netball                Row          Swim
T_400m
       0            0                0             0           37
22             0
T_Sprnt        Tennis        W_Polo
       0            0             0
60    data analysis, graphics, and visualisation using r

6.2.5       Handlng rows that include missing values
The function na.omit() omits rows that contain one or more miss-
ing values. The argument may be a data frame or a matrix. The
function complete.cases() identifies such rows. Thus:
test.df            d a t a . f r a m e ( x=c ( 1 : 2 ,NA) , y = 1 : 3 )
test.df
   x    y
1 1     1
2 2     2
3 NA    3

## complete.cases ()
complete.cases ( t e s t . d f )
[1]     TRUE       TRUE FALSE

## na.omit ()
na.omit ( t e s t . d f )
  x y
1 1 1
2 2 2



6.3      Matrices, Arrays and Tables
6.3.1       Matrices ­ Vectors with a Dimension
When printed, matrices appear in a row by column layout in which
all elements have the same mode ­ commonly numeric or character
or logical. Internally matrix elements are stored as one long vector in
which the columns are stacked one above the other. The first element
in the dimension attribute determines the number of rows in each
column.
     Numeric matrices and data frames where all elements have the
same vector mode are for many purposes equivalent. Depending
however on the calculation that is to be performed, matrices and data
frames may require a dierent syntax, or even explicit conversion
from one to the other. Proceed with care!
     The dimension attribute can be examined thus:
travelmat               as.matrix ( travelbooks [ , 1:4])
dim ( t r a v e l m a t )    # Or: attr(travelmat , "dim ")
[1] 6 4

a t t r ( t r a v e l m a t , " dim " )
[1] 6 4
                                                                        data objects and functions        61

Removal of the dimension attribute
The dimension attribute can be changed or removed, thus:
travelvec                 as.matrix ( travelbooks [ , 1:4])
dim ( t r a v e l v e c )     NULL # Columns of travelmat
                                      # are stacked into one
                                      # long vector
travelvec

 [1]    1.3         3.9       1.2       2.0      0.6       1.5
11.3
 [8]   13.1        20.0      21.1     25.8      13.1     23.9
18.7
[15]   27.6        28.5      36.0     23.4    250.0     840.0
550.0
[22] 1360.0       640.0    420.0

  # as(travelmat , " vector ") is however preferable


Submatrices
The syntax travelmat[1:3,] extracts the first three rows of the         The $ notation, used with data
matrix travelmat. For columns 1 to 3, specify travelmat[,               frames and other list objects to ex-
1:3] Negative indices can be used, as for data frames to omit rows      tract the contents of list elements,
                                                                        is not relevant to matrices.
and/or columns.

6.3.2   Arrays in general
A matrix is a two-din=mensional array. More generally, arrays can
have an arbitrary number of dimensions.

6.3.3   Tables of Counts
Use the functions table() or xtabs() to make a table of counts.
Use xtabs() for cross-tabulation, i.e., to determine totals of nu-
meric values for each table category.

6.3.4   The table() function
For use of table(), specify one vector of values (often a factor) for
each table margin that is required. For example:
l i b r a r y (DAAG)             # possum is from DAAG
w i t h ( possum , t a b l e ( Pop , s e x ) )

       sex
Pop      f m
  Vic   24 22
  other 19 39
62   data analysis, graphics, and visualisation using r

NAs in tables
By default, table() ignores NAs. To show information on NAs,
specify exclude=NULL, thus:
l i b r a r y (DAAG)
t a b l e ( nswdemo$ r e 7 4 ==0 , e x c l u d e =NULL)


FALSE      TRUE      <NA >
  119       326       277



The xtabs() function
This more flexible alternative to table() uses a table formula to
specify the margins of the table:
x t a b s (  Pop+sex , d a t a =possum )

       sex
Pop      f m
  Vic   24 22
  other 19 39

     A column of frequencies can be specified on the left hand side of
the table formula. In order to demonstrate this, the three-way table
UCBAdmissions (datasets package), which we encountered earlier
in Section 6.3.1, will be turned into a data frame.
     The following creates a data frame equivalent of the table. Mar-
gins in the table become columns in the data frame:
UCBdf         a s . d a t a . f r a m e . t a b l e ( UCBAdmissions )
h e a d ( UCBdf , n =3)

     Admit Gender Dept Freq
1 Admitted   Male    A 512
2 Rejected   Male    A 313
3 Admitted Female    A   89

    Now form a table of total admissions admissions and rejections
in each department:
x t a b s ( Freq      Admit+Dept , d a t a =UCBdf )

          Dept
Admit        A   B   C   D   E   F
  Admitted 601 370 322 269 147 46
  Rejected 332 215 596 523 437 668
                                                                         data objects and functions        63

6.3.5    Data frames versus matrices and tables
Note that for a matrix length() returns the number of elements,          Computations with matrices are
while for a data frame it returns the number of columns:                 typically much faster than their
                                                                         equivalents with data frames.
length ( travelbooks )                                                      Modeling functions commonly
[1] 8                                                                    return larger numeric objects as
                                                                         matrices rather than data frames.
                                                                         The principal components function
travelmat      as ( t r a v e l b o o k s [ , 1 : 4 ] , " matrix " )
                                                                         prcomp() returns scores as a ma-
length ( travelmat )
                                                                         trix, as does the linear discriminant
[1] 24                                                                   analysis function lda() from the
                                                                         MASS package.
    Functions are available to convert data frames into matrices, and
vice versa. For example:
travelmat    as.matrix ( travelbooks [ , 1:4])
  # From data frame to matrix
newtravelbooks    as.data.frame ( travelmat )
  # From matrix to data frame



6.4      Functions
Dierent Kinds of Functions:
 Generic     The 'class' of the function argument determines the
             action taken. E.g., print(), plot(), summary()
  Modeling         For example, lm() fits linear models.
                   Output may be stored in a model object.
  Extractor        These extract information from model objects.
                   Examples include summary()), coef()),
                   resid()), and fitted()
  User             Use, e.g., to automate and document computations
  Anonymous        These are user functions that are defined at the
                   point of use, and do not need a name.

     The above list is intended to include the some of the most impor-
tant types of function. These categories may overlap.
     The language that R implements has many of the features of a        Functions for working with dates
functional language. Functions have accordingly featured throughout      are discussed in Section 6.4.7
the earlier discussion. Here will be noted functions that are com-       immediately following.
monly important.

6.4.1    Built-In Functions
Common useful functions
64   data analysis, graphics, and visualisation using r


## Use with any R object as argument
print() # Prints a single R object
length() # Number of elements in a vector or of a list

## Concatenate and print R objects [does less coercion than print()]
cat() # Prints multiple objects, one after the other

## Use with a numeric vector argument
mean() # If argument has NA elements, may want na.rm=TRUE
median() # As for mean(), may want na.rm=TRUE
range() # As for mean(), may want na.rm=TRUE
unique() # Gives the vector of distinct values
diff() # Vector of first differences
               # N. B. diff(x) has one less element than x
cumsum() # Cumulative sums, c.f., also, cumprod()

## Use with an atomic vector object
sort() # Sort elements into order, but omitting NAs
order() # x[order(x)] orders elements of x, with NAs last
rev() # reverse the order of vector elements
any() # Returns TRUE if there are any missing values
as() # Coerce argument 1 to class given by argument 2
               # e.g. as(1:6, "factor")
is() # Is argument 1 of class given by argument 2?
               # is(1:6, "factor") returns FALSE
               # is(TRUE, "logical") returns TRUE
is.na() # Returns TRUE if the argument is an NA

## Information on an R object
str() # Information on an R object
args() # Information on arguments to a function
mode() # Gives the storage mode of an R object
               # (logical, numeric, character, \ldots, list)

## Create a vector
numeric() # numeric(5) creates a numeric vector, length 5,
               # all elements 0.
               # numeric(0) (length 0) is sometimes useful.
character() # Create character vector; c.f. also logical()



    The function mean(), and a number of other functions, takes
the argument na.rm=TRUE; i.e., remove NAs, then proceed with the
calculation. For example

> mean(c(1, NA, 3, 0, NA), na.rm=T)
[1] 1.3


    Note that the function as() has, at present, no method for coerc-
ing a matrix to a data frame. For this, use as.data.frame().
                                                                         data objects and functions        65

Functions in dierent packages with the same name
For example, as well as lattice function dotplot() the graphics
package has a defunct function dotplot(). To be sure of getting the
lattice function dotplot(), refer to it as lattice::dotplot.

6.4.2    Functions for data manipulation                                 For data manipulation, note in
                                                                         particular:
Subsection 6.4.5 will discuss the use of the apply family of func-
tions. The reshape2 and plyr packages will be discussed in Chapter       - the apply family of functions
7.                                                                       - functions for creating and
                                                                           working with tables

Information on data objects                                              - data manipulation functions in
                                                                           the reshape2 and plyr packages.
The function str() gives basic information on the data object that is
given as argument.
l i b r a r y (DAAG)
s t r ( possumsites )

'data.frame ':   7 obs. of 3 variables :
 $ Longitude : num 146 149 151 153 153 ...
 $ Latitude : num -37.5 -37.6 -32.1 -28.6 -28.6 ...
 $ altitude : num 800 300 300 400 200 400 600



6.4.3    Utility functions
dir() # List files in the working or other specified directory
sessionInfo() # Print version numbers for R and for attached packages
system.file() # By default, show path to 'package="base"'
R.home() # Path to R home directory
.Library # Path to the default library
.libPaths() # Get/set paths to library directories

Section 14 has further details.

6.4.4    User-defined functions
The function mean() calculates means, The function sd() calcu-
lates standard deviations. Here is a function that calculates mean and
standard deviation at the same time:
mean.and.sd       function ( x ){
   av      mean ( x )
   sdev      sd ( x )
   c ( mean=av , s d = s d e v )  # return value
}

   The parameter x is the argument that the user must supply. The
body of the function is enclosed between curly braces. The value
66   data analysis, graphics, and visualisation using r

that the function returns is given on its final line. Here the return
value is a vector that has two named elements.
     The following calculates the mean and standard deviation of
heterozygosity estimates for seven dierent Drosophila species.5          5
                                                                          Data are from Lewontin, R. 1974.
hetero    c ( .43 , .25 , .53 , .47 , .81 , .42 , .61 )                  The Genetic Basis of Evolutionary
mean.and.sd ( hetero )                                                   Change.

  mean     sd
0.5029 0.1750

     It is useful to give the function argument a default value, so
that it can be run without user-supplied parameters, in order to see
what it does. A possible choice is a set of random normal numbers,
perhaps generated using the rnorm() function.
     Here is a revised function definition. Because the function body    Note that a dierent set of random
has been reduced to a single line, the curly braces are not needed.      numbers will be returned, giving a
                                                                         dierent mean and SD, each time
mean.and.sd           f u n c t i o n ( x = rnorm ( 2 0 ) )
                                                                         that the function is run with its
                          c ( mean=mean ( x ) , s d=s d ( x ) )
                                                                         default argument.
mean.and.sd ( )
   mean          sd
-0.1726      1.0324

mean.and.sd ( )
  mean     sd
0.4908 1.1191

    Functions can be defined at the point where they are used. Such
functions do not need a name, and are called anonymous functions.
Section 6.3.4 has an example.

6.4.5    The apply family of functions
                                                                         For the apply family of functions,
apply(), sapply() and friends
                                                                         specify as the FUN argument any
  apply()       Use apply() to apply a function across rows              function that will not generate an
                or columns of a matrix (or data frame)                   error. Obviously, log("Hobart")
                                                                         is not allowed!
  sapply()      sapply() and lapply() apply functions in
                                                                         Note also the function tapply(),
  & friends     parallel across columns of a data frame, or across       which will not be discussed here.
                elements of a list, or across elements of a vector.

apply(): The function apply() is intended for use with matrices
or, more generally, with arrays. It can also be used with data frames,
in which case the data frame is first coerced to matrix. It has three
mandatory arguments, a matrix or data frame, the dimension (1
for rows; 2 for columns) or dimensions, and a function that will be
applied across that dimension of the matrix or data frame. Here is an
example:                                                                 Code that will input molclock:
                                                                           data objects and functions         67

apply ( molclock , 2 , range )

   The following tabulates admissions, in the three-way table
UCBAdmissions, according to sex:
a p p l y ( UCBAdmissions , c ( 1 , 2 ) , sum )

          Gender
Admit      Male Female
  Admitted 1198    557
  Rejected 1493   1278



sapply() and lapply(): The function sapply() returns the                   Warning: Use apply() with
same information as lapply(). But whereas lapply() returns a               COLUMN=2, to apply a function
list, sapply() tries if possible to simplify the result to give a vector   to all columns of a matrix. If
                                                                           sapply() or lapply() is given a
or matrix or array.
                                                                           matrix as argument, the function
      The functions sapply() and lapply() make it possible to              is applied to each element (the
apply functions such as mean(), range(), etc., in parallel to all          matrix is treated as a vector).
columns of a data frame. They take as arguments the name of the
data frame, and the function that is to be applied.
      Here is an example of the use of sapply():
s a p p l y ( molclock , range )

                                                                           Use of na.rm=TRUE:
     Gpdh Sod Xdh AvRate Myr
[1,] 1.5 12.6 11.5  11.9   55                                              s a p p l y ( molclock , range ,
[2,] 40.0 46.0 31.7 24.9 1100                                                            n a . r m=TRUE)

                                                                                 Gpdh Sod
    A third argument na.rm=TRUE                                            Xdh AvRate Myr
    can be supplied to the function sapply. This argument is then          [1 ,] 1.5 12.6 11.5
automatically passed to the function that is given in the second argu-     11.9    55
                                                                           [2 ,] 40.0 46.0 31.7
ment position.
                                                                           24.9 1100
    More generally, the first argument to sapply() or lapply()
can be any vector.


sapply() ­ a further example
We will demonstrate the use of sapply() to apply a function that
counts the number of NAs to each column of a data frame. The func-
tion can be defined and then used. In this case, the function is:
countNA         f u n c t i o n ( x ) sum ( i s . n a ( x ) )

    Alternatively, define in place6 a function that counts number of       6
                                                                            A function that is defined in
NAs can be defined in place.                                               place does not need a name, and is
    Here are the two ways to do the calculation:                           known as an anonymous function.
68   data analysis, graphics, and visualisation using r

Use function defined earlier:                            Define function at place of call:
sapply ( Pima.tr2 [ , 1:5] ,                             sapply ( Pima.tr2 [ , 1:5] ,
         countNA )                                                f u n c t i o n ( x ) sum ( i s . n a ( x ) ) )

npreg       glu        bp     skin        bmi            npreg         glu         bp     skin         bmi
    0         0        13       98          3                0           0         13       98           3



6.4.6    Functions for working with text strings
The functions paste() and paste0() join text strings. The function                           For paste(), the default is to use
sprintf(), which is primarily designed for formatting output for                             a space as a separator; paste0()
printing, oers a useful extension of what is possible using paste()                          omits the space.
and paste0().
     Other simple string operations include substring() and
nchar() (number of characters). Both these functions, and
strsplit() noted in the next paragraph, can be applied to char-
acter vectors.
     For splitting strings, note strsplit(). Note the argument
fixed, by default set to FALSE. The eect of this is that the argu-
ment split(), used to identify the character(s) on which the string
will split, is assumed to be a regular expression. See help(regexp)
for details. For use of strsplit() to split at a given text string, call
strsplit() with fixed=FALSE. This ensures that the argument
split is treated as a character string.
     The same considerations apply to other functions that accept
an argument fixed that determines whether a search string will
be treated as a regular expression. These include the search func-
tions grep() and regexpr(), and the search and replace functions
sub() and gsub().
     Here are the species of birds represented in the dataset cuckoos,
in the DAAG package:
( spec       l e v e l s ( cuckoos $ s p e c i e s ) )

[1] "hedge. sparrow " " meadow . pipit"                     "pied. wagtail "
                                                                                             Regular expression substitution:
[4] "robin"           "tree. pipit"                         "wren"
                                                                                              specnam
     Now replace the periods in the names by spaces:                                          sub ( " \ \ . " , " " , spec )

( specnam         s u b ( " . " , " " , s p e c , f i x e d =TRUE ) )                          In regular expressions enter a
                                                                                             period (".") as "\\."
[1] "hedge sparrow " " meadow pipit"                        "pied wagtail "
[4] "robin"          "tree pipit"                           "wren"

   For string matching, note match(), pmatch() and
charmatch(). For matching using regular expressions, note
grep() and regexpr(). For string substitution, note sub() and
gsub().
                                                                     data objects and functions          69

   The following web pages have helpful information on string
manipulation in R:
 http://www.stat.berkeley.edu/classes/s133/R-6.html                  Overview
 http://en.wikibooks.org/wiki/R_Programming/Text_
Processing                                                           A more detailed account
On the use of regular expressions, see help(regex).
    The package stringr, due to Hadley Wickham, provides what
may be a more consistent set of functions for string handling than
are available in base R. For strings representing biological se-
quences, install the Bioconductor package Biostrings. This has
extensive documentation.

6.4.7      Functions for Working with Dates (and Times)
The R base system has several functions for working with dates.
For detailed information, see help(Dates), help(as.Date) and
help(format.Date).
    Use as.Date() to convert character strings into dates. The
default format has year, then month, then day of month, thus:
# Electricity Billing Dates
dat    c ( " 2003 08 24 " , " 2003 11 23 " , " 2004 02 22 " ,
           " 2004 05 03 " )
dd    as.Date ( dat )

   Use format() to set or change the way that a date is formatted.
The following is a selection of the available symbols:
      %d:        day, as number
      %a:        abbreviated weekday name (%A: unabbreviated)
      %m:        month (00-12)
      %b:        month abbreviated name (%B: unabbreviated)
      %y:        final two digits of year (%Y: all four digits)
    The default format is "%Y-%m-%d". The character / can be used
in place of -. Other separators (e.g., a space) must be explicitly
specified, using the format argument, as in the examples below.
    There are both subtraction and diff() methods for date ob-       Subtraction yields a time dif-
jects:                                                               ference object. If necessary, use
                                                                     unclass() to convert this to a
a s . D a t e ( " 1960 12 1 " )   a s . D a t e ( " 1960 1 1 " )     numeric vector.

Time difference of 335 days

d i f f ( dd )

Time differences in days
[1] 91 91 71
70    data analysis, graphics, and visualisation using r

u n c l a s s ( d i f f ( dd ) )

[1] 91 91 71
attr (," units ")
[1] "days"

    By default, dates are stored in integer numbers of days, using
January 1 1970 as origin. Use as.integer() or julian() to con-
vert a date into its integer value. Here are examples:
a s . D a t e ( " 1 / 1 / 1960 " , f o r m a t ="%d /%m/%Y" )

[1] "1960 -01 -01"

a s . D a t e ( " 1 : 1 2 : 1 9 6 0 " , f o r m a t ="%d:%m:%Y" )

[1] "1960 -12 -01"

a s . D a t e ( " 31 / 12 / 1960 " , "%d /%m/%Y" )

[1] "1960 -12 -31"

chargedates                  c ( " 1 / 1 / 1970 " , " 1 / 1 / 2000 " , " 1 / 1 / 2010 " )
a s . i n t e g e r ( a s . D a t e ( c h a r g e d a t e s , "%d /%m/%Y" ) )

[1]            0 10957 14610

      Use format() to fine tune the formatting of dates for printing.                        See help(format.Date).
dec1           a s . D a t e ( " 2004 12 1 " )
f o r m a t ( dec1 , f o r m a t ="%b %d %Y" )

[1] "Dec 01 2004"

f o r m a t ( dec1 , f o r m a t ="%a %b %d %Y" )

[1] "Wed Dec 01 2004"
                                                                                                   1840                                
                                                                                                                                    

    Such formatting may be used to give meaningful labels on                                       1820
                                                                                                                              
                                                                                                                                    


graphs. For an example, see ??. Here is an example:                                                1800                  
                                                                                                                                
                                                                                                                                
                                                                                              BC




                                                                                                                        
                                                                                                                        
                                                                                                   1780
## Labeling of graph: data frame jobs (DAAG)                                                                   
                                                                                                                   
                                                                                                                   
                                                                                                                      
                                                                                                             
l i b r a r y (DAAG) ; l i b r a r y ( l a t t i c e )                                             1760
                                                                                                            
                                                                                                              
                                                                                                              
                                                                                                                      


fromdate                a s . D a t e ( " 1 J a n 1 9 9 5 " , f o r m a t ="%d%b%Y" )              1740      


startofmonth                    s e q ( from= f r o m d a t e , by=" 1 month " ,                          Jan95 Jul95 Jan96 Jul96
                                        l e n g t h =24)                                                         startofmonth
atdates               s e q ( from= f r o m d a t e , by=" 6 month " ,
                              l e n g t h =4)                                                Figure 6.1: Dates are used to label
x y p l o t (BC  s t a r t o f m o n t h , d a t a = j o b s ,                               the x-axis
              s c a l e = l i s t ( x= l i s t ( a t = a t d a t e s ,
                                                  l a b e l s =format ( a t d a t e s ,
                                                                           "%b%y " ) ) ) )
                                                                                      data objects and functions      71

    See help(seq.Date) for generation of regular sequences of
dates.
    Other useful functions include weekdays(), months()                               Note also date() which returns
quarters() julian(). For example:                                                     the current date and time, and
                                                                                      Sys.Date() which returns the
days      c ( " 2003 08 24 " , " 2003 11 23 " ,                                       date. For information on func-
              " 2004 02 22 " , " 2004 05 03 " )                                       tions for working with times, see
dd    a s . D a t e ( days )                                                          help(ISOdatetime). The CRAN
weekdays ( dd )                                                                       Task View for Time Series Anal-
                                                                                      ysis has notes on classes and
[1] " Sunday " " Sunday " " Sunday " " Monday "
                                                                                      methods for working with times
                                                                                      and dates, and on packages that
j u l i a n ( dd )                                                                    provide useful functionality.
[1] 12288 12379 12470 12541
attr (," origin ")
[1] "1970 -01 -01"



6.4.8      Summaries of Information in Data Frames
A common demand is to obtain a tabular summary of information in
several columns of a data frame or in in all columns, broken down
according to the levels of one or more grouping variables. For exam-
ple, the dataframe nswdemo (DAAG), has the variables re74, re75
and re78 (income in 1974, 1975 and 1978 respectively), from both
a control group (trt==0) and a treatment group (trt==1). For each
of the two groups and for each of the three variables, the following
calculates the number of zeros:
## Define a function that counts zeros
countzeros                f u n c t i o n ( x ) sum ( ! i s . n a ( x ) & x ==0)
a g g r e g a t e ( nswdemo [ , c ( " r e 7 4 " , " r e 7 5 " , " r e 7 8 " ) ] ,
                    by= l i s t ( g r o u p=nswdemo$ t r t ) ,
                   FUN= c o u n t z e r o s )

    group re74 re75 re78
1       0 195 178 129
2       1 131 111     67

    The data frame is split according to the grouping elements that
are given by the by argument, and the function is then applied to
each of the columns in each of the splits.
    Now find the proportion, excluding NAs, that are zero. The result
will be printed out with improved labeling of the rows:
## countprop () counts proportion of zero values
countprop              function ( x ){
     sum ( ! i s . n a ( x ) & x ==0) / l e n g t h ( n a . o m i t ( x ) ) }
prop0
  a g g r e g a t e ( nswdemo [ , c ( " r e 7 4 " , " r e 7 5 " , " r e 7 8 " ) ] ,
                      by= l i s t ( g r o u p=nswdemo$ t r t ) ,
72    data analysis, graphics, and visualisation using r

                    FUN= c o u n t p r o p )
## Now improve the labeling
rownames ( p r o p 0 )        c ( " Control " , " Treated " )
r o u n d ( prop0 , 2 )

              group re74 re75 re78
Control           0 0.75 0.42 0.30
Treated           1 0.71 0.37 0.23

    The calculation can alternatively be handled by two calls to the
function sapply(), one nested within the other, thus:
prop0
  s a p p l y ( s p l i t ( nswdemo [ , c ( " r e 7 4 " , " r e 7 5 " , " r e 7 8 " ) ] ,   The argument z in the func-
                            nswdemo$ t r t ) ,                                              tion that is defined in place is a
               FUN= f u n c t i o n ( z ) s a p p l y ( z , c o u n t p r o p ) )           data frame. The argument x to
round ( t ( prop0 ) , 2)                                                                    countprop() is a column of a data
                                                                                            frame.
  re74 re75 re78
0 0.75 0.42 0.30
1 0.71 0.37 0.23



6.5      *Classes and Methods (Generic Functions)
Key language constructs:
  Classes        Classes make generic functions (methods) possible.
  Methods        Examples are print(), plot(), summary(), etc.

     There are two implementation of classes and methods, the orig-
inal S3 implementation, and the newer S4 implementation that is
implemented in the methods package. Here, consider the simpler S3
implementation.                                                                             Consider the generic func-
     All objects have a class. Use the function class() to get this                         tion print(). For a factor,
information. For many common tasks there are generic functions ­                            print.factor() is used, for a
                                                                                            data frame print.data.frame()
print(), summary(), plot(), etc., whose action varies according
                                                                                            is used, and so on. Ordered fac-
to the class of object to which they are applied.                                           tors "inherit" the print method
     To get details of the S3 methods that are available for a generic                      for factors. For objects that do
function such as plot(), type, e.g., methods(plot). To get a list of                        not have an explicit print method,
the S3 methods that are available for objects of class lm, type, e.g.,                      print.default() handles the
methods(class="lm")                                                                         printing.


6.5.1       S4   methods
                                                                                            Packages that use S4 classes and
The S4 conventions and mechanisms extend the abilities available                            methods include lme4, Biocon-
under S3, build in checks that are not available with S3, and are                           ductor packages, and most of the
more conducive to good software engineering practice.                                       spatial analysis packages.
                                                                                               data objects and functions                                73

Example ­ a spatial class
The function bubble() in the sp package is designed for plot-
ting spatial measurement data. Each point (location) is shown as
a bubble, by default with the area of the bubble proportional to
the value of a quantity that is measured at that point. The function
coordinates() can be used, given spatial coordinates, to turn a
data frame or matrix into an object of one of the requisite classes.
    Data from the data frame meuse,7 from the sp package, will be                              7
                                                                                                 Data are from the floodplain of
used by way of example. A first step is to create an object of one of                          the river Meuse, in the Nether-
the classes that the function bubble() accepts as argument, thus:                              lands. It includes concentrations of
                                                                                               various metals (cadmium, copper,
l i b r a r y ( sp )                                                                           lead, zinc), with Netherlands
d a t a ( meuse )                                                                              topographical map coordinates.
c l a s s ( meuse )

[1] "data.frame"

c o o r d i n a t e s ( meuse )          x + y
c l a s s ( meuse )

[1] " SpatialPointsDataFrame "
attr (," package ")
[1] "sp"
                                                                                                                                    zinc

   This has created an object of the class                                                                                                     
                                                                                                                                               
SpatialPointsDataFrame.                                                                                   333000                          
                                                                                                                                          
                                                                                                                                        
                                                                                                                                            
                                                                                                                                           
                                                                                                                                              


                                                                                                                                          
                                                                                                                                         
                                                                                                                                        

   Code that creates the plot, shown in Figure 6.2, is:                                                                  
                                                                                                                          
                                                                                                                          
                                                                                                                           
                                                                                                                           
                                                                                                                            
                                                                                                                                                  
                                                                                                                                                     113
                                                                                               Northing



                                                                                                          332000          
                                                                                                                                                     198
                                                                                                                       
                                                                                                                    
                                                                                                                                        
                                                                                                                                                     326
b u b b l e ( meuse , z c o l =" z i n c " , s c a l e s = l i s t ( t c k =0 . 5 ) ,
                                                                                                                      
                                                                                                                                        
                                                                                                                      
                                                                                                                                                     674.5
                                                                                                                      
                                                                                                                                                  
                                                                                                                                     

                                                                                                          331000                                     1839
              m a x s i z e =2 , x l a b =" E a s t i n g " , y l a b =" N o r t h i n g " )                         
                                                                                                                              
                                                                                                                   
                                                                                                                   
                                                                                                                        
                                                                                                                              

                                                                                                                     
                                                                                                                    
                                                                                                                       
                                                                                                                     
                                                                                                                        
                                                                                                                        
                                                                                                                           
                                                                                                                                           

    The function bubble() uses the abilities of the lattice pack-
                                                                                                          330000           
                                                                                                                     


age. It returns a trellis graphics object.                                                                     178500 179500 180500 181500

                                                                                                                           Easting
    The coordinates can be extracted using coordinates(meuse).
Remaining columns from the original data frame are available from                              Figure 6.2: Bubble plot for zinc
the data frame meuse@data.                                                                     concentrations. Areas of bubbles
    Use slotNames() to examine the structure of the object:                                    are proportional to concentrations.
s l o t N a m e s ( meuse )

[1] "data"                        " coords .nrs" " coords "
[4] "bbox"                        " proj4string "
                                                                                               Note that meuse@data is shorthand
     Typing names(meuse) returns the column names for the data                                 for slot(meuse, "data").
slot. The eect is the same as that of typing names(meuse@data).
To get a list of the S4 methods that are available for a generic func-
tion, use the function showMethods(). Section 13.4 has further
details.
     The various R packages for spatial data analysis make ex-
tensive use of the classes SpatialPointsDataFrame and
SpatialGridDataFrame.
74     data analysis, graphics, and visualisation using r


6.6       Common Sources of Surprise or Di culty
     Character vectors, when incorporated as columns of a data frame,
     become by default factors.

     Factors can often be treated as vectors of text strings, with values
     given by the factor levels. Watch however for contexts where the
     integer codes are used instead.

     Use is.na() to check for missing values. Do not try to test for
     equality with NA. Refer back to Section 6.1.3.

     If there is a good alternative, avoid the attaching of data frames.    Assignment of new values to an
     If you do use this mechanism, be aware of the traps.                   attached data frame creates a new
                                                                            local data frame with the same
     The syntax elasticband[,2], extracts the second column from            name. The new local copy remains
     the data frame elasticband, yielding a numeric vector. Observe         in the workspace when the data
     however that elasticband[2, ] yields a data frame, rather than         frame is detached.
     the numeric vector that the user may require. Use the function
     unlist() to extract the vector of numeric values.


6.7       Summary
     Important R data structures are vectors, factors, data frames and
     lists. Vector modes include numeric, logical, character or complex.

     The function c() (concatenate) joins vector elements together          More generally, the function c()
     into vectors. It may be used for logical and character vectors, as     may be used to join lists, which
     well as for numeric vectors.                                           are "non-atomic" vectors.

     Factors, used for categorical data, can be important in the use of
     many of R's modeling functions. Ordered factors are appropriate
     for use with ordered categorical data.
     Use table() for tables of counts, and xtabs() for tables of
     counts or totals.
     R allows the use of infinite Values (Inf or -Inf) and NaNs (not a
     number) in calculations. If you introduce such quantities into your
     calculations, be sure that you understand the implications.
     A matrix is a vector that is stacked column upon column into
     a rectangular array that has dimensions given by its dimension
     attribute. A data frame is, by contrast, a list of columns.
     In a limited range of contexts, matrices are handled similarly
     to data frames whose elements are all of one type (typically all
     numeric). Where it is possible to work with matrices rather than
     data frames, this can greatly speed up calculations.
                                                                                  data objects and functions     75

     Modeling functions typically output a model object that has a list           Generic functions that are avail-
     structure. This holds information from the model fit, in a form              able for use with model ob-
     from which generic model functions can then extract output that              jects typically include print(),
                                                                                  summary(), fitted(), coef() and
     users commonly require.
                                                                                  resid().


 6.8       Exercises
1. Find an R function that will sort a vector. Give an example of its
   use.

2. Modify the function mean.and.sd() so that it outputs, in ad-
   dition to the mean and standard deviation, the number of vector
   elements.

3.    What   is the mode of: (i) a factor; (ii) a dataframe?; (iii) a list that
     is not necessarily a dataframe?
     Find out by applying the function mode() to objects of each of
     these classes. Explain what you find.

4. The attempt to assign values to an expression whose subscripts
   include missing values generates an error. Run the following code
   and explain the error that results:
     y      c ( 1 , NA, 3 , 0 , NA)
     y [ y > 0]
     y [ y > 0]       c (11 , 12)
76   data analysis, graphics, and visualisation using r
 7
 Data Entry, Manipulation and Management

 Data analysis has as its end point the use of forms of data summary
 that will convey, fairly and succinctly, the information that is in the
 data. The fitting of a model is itself a form of data summary.
      Later sections will discuss the mechanics of simple forms of         Data summaries that can lead
 data summary. There will be attention to the scope that simple forms      to misleading inferences arise
 of data summary, which seem superficially harmless, oer for mis-          often, from a unbalance in the data
                                                                           and/or failure to account properly
 leading inferences. These issues aect, not just data summary per se,
                                                                           for important variables or factors.
 but all modeling.


 Alternative types of data objects
 The manipulations that will be described will usually involve one of
 the following dierent types of object:

Column objects: These include (atomic) vectors, factors, and dates.
Date and date-time objects: The creation and manipulations of date
 objects will be described below.
Data Frames: These are rectangular structures. Columns may be              A data frame is a list of column
 "atomic" vectors, or factors, or other objects (such as dates) that are   objects, all of the same length.
 one-dimensional.
Matrices and arrays: Matrices1 are rectangular arrays in which             1
                                                                            Internally, matrices are one
 all elements have the same mode. An array is a generalization of a        long vector in which the columns
 matrix to allow an arbitrary number of dimensions.                        follow one after the other.

Tables: A table is a specialized form of array.
Lists: A list is a collection of objects that can be of arbitrary class.
 Lists are"recursive" data structures, i.e., elements of lists are them-
 selves lists.
S3 model objects: These are lists that have a defined structure.
S4 objects: These are specialized data structures with tight control
 on the structure. Unlike S3 objects, they cannot be manipulated as
 lists. Modeling functions in certain of the newer packages, notably
78    data analysis, graphics, and visualisation using r

lme4, the Bioconductor packages, and the spatial analysis packages,
return S4 objects.


7.1      Lists
A list is a collection of arbitrary objects. Above, we noted that a                               Elements of lists are themselves
data frame is a specialized form of list. Consider for example the                                lists. Distinguish rcanberra[4],
list                                                                                              which is a sub-list and therefore a
                                                                                                  list, from rcanberra[[4]] which
rcanberra             l i s t ( s o c i e t y =" s s a i " , b r a n c h =" C a n b e r r a " ,   extracts the contents of the fourth
                                p r e s e n t e r =" J o h n " ,                                  list element.
                                t u t o r s =c ( "Emma" , " C h r i s " , " F r a n k " ) )
     Observe the following:
                                                                                                  List elements can be accessed
length ( rcanberra )             # rcanberra has 4 elements
                                                                                                  by name. Thus, to extract the
[1] 4                                                                                             contents of the 4th list element,
                                                                                                  alternatives to rcanberra[[4]]
names ( r c a n b e r r a )                                                                       are rcanberra[["tutors"]] or
                                                                                                  rcanberra$tutors.
[1] " society "               " branch "         " presenter " " tutors "

## Now extract the 4th list element.
rcanberra [4]      # This is a list , with name ' tutors '

$tutors
[1] "Emma"          " Chris" " Frank"

rcanberra [[4]]                  # Contents of the 4th list element

[1] "Emma"          " Chris" " Frank"

rcanberra $ tutors               # Equivalent to rcanberra [[4]]

[1] "Emma"          " Chris" " Frank"


Model objects are lists
As noted in Subsection 5.2.2, the various R modeling functions all                                Recall again, also, that data frames
return their own particular type of model object, either a list or as an                          are a specialized form of list, with
S4 object.                                                                                        the restriction that all columns
                                                                                                  must all have the same length.

7.2      Manipulations Involving Matrices, Arrays
         and Tables
7.2.1     Matrix manipulations
Let X (n by p), Y (n by p) and B (p by k) be numeric matrices. Some
of the possibilities are:
                                                                      data entry, manipulation and management       79

X + Y                 #   Elementwise addition
X * Y                 #   Elementwise multiplication
X %*% B               #   Matrix multiplication
s o l v e (X, Y)      #   Solve X B = Y
s v d (X)             #   Singular value decomposition of X
q r (X)               #   QR decomposition of X.

    Use the function t() to transpose matrices, so that rows and                   The function t() can also be used
columns are interchanged.                                                          with data frames, returning a ma-
    Calculations with data frames that are slow and time consum-                   trix. All values are, if necessary,
                                                                                   coerced to the same mode.
ing will often be much faster if they can be formulated as matrix
calculations. Section 7.8 has examples.
    Section 6.4.5 will discuss the use of apply() for operations
with matrices, arrays and tables.


7.2.2     Table margins
Here, calculations start with an existing table. Consider as an ex-
ample the data in the multi-way table UCBAdmissions (datasets
package).
    First, calculate overall admission rates (percentages) for females
and males. The following retains margin 1 (Admit) and margin 2
(Gender), adding over Dept (the remaining margin):
                                                                                   Margin 2 is taken before mar-
## Tabulate by Admit ( margin 2) and Gender ( margin 1)
                                                                                   gin 1, in order to ensure that the
( byGender   m a r g i n . t a b l e ( UCBAdmissions , m a r g i n = 2 : 1 ) )
                                                                                   rows will correspond to levels of
                                                                                   Gender.
         Admit
Gender    Admitted Rejected
  Male         1198    1493
  Female        557    1278

    Use will be made, as earlier, of a function props that calculates
the proportion of the total in the first (or other nominated element) of
a vector:
props         f u n c t i o n ( x , elem =1) sum ( x [ elem ] ) / sum ( x )

    For example:
## % admitted for each level of margin 1 ( Gender )
r o u n d ( 1 0 0 * a p p l y ( byGender , 1 , p r o p s ) , 2 )

  Male Female
 44.52 30.35

   Admission rates will now be calculated for individual depart-
ments:
## Admission rates , by department
r o u n d ( 1 0 0 * a p p l y ( UCBAdmissions , 2 : 3 , p r o p s ) , 2 )
80    data analysis, graphics, and visualisation using r


        Dept
Gender       A     B     C     D     E    F
  Male   62.06 63.04 36.92 33.09 27.75 5.90
  Female 82.41 68.00 34.06 34.93 23.92 7.04

    The table retains the margin 2 ((Gender) and margin 3 (Dept).
Proportions are calculated for level 1 of the remaining margin, which
is Admit. As a fraction of those who applied, females were strongly
favored in department A, and males somewhat favored in depart-
ments C and E. Notice that overall admission rates were high ib
departments A and B, and low in other departments. The overall
bias arose because males favored departments where admission rates
were relatively high.                                                                  The high number of males apply-
    Look now, for each department, at the numbers of males ap-                         ing to A and B biases the male
plying as a proportion of the total number of male applicants, and                     rates towards the high admission
                                                                                       rates in A and B, while the rel-
similarly for females. For calculating the proportions, the function
                                                                                       atively high number of females
prop.table() can be used:                                                              applying to C, D and F biases the
                                                                                       overall female rates towards the
7.2.3       Categorization of continuous data                                          low admission rates in C, D and F.

The data frame bronchit, in the SMIR package, has observations on
212 men in a sample of Cardi (Wales, UK) enumeration districts.
Variables are r (1 if respondent suered from chronic bronchitis and
0 otherwise), cig (number of cigarettes smoked per day) and poll
(the smoke level in the locality).                                                     An alternative to accessing SMIR
    It will be convenient to define a function props that calculates                   is to load bronchit.RData from
the proportion of the total in the first (or other nominated element) of               the url noted on the reverse of the
                                                                                       title page.
a vector:
props            f u n c t i o n ( x , elem =1) sum ( x [ elem ] ) / sum ( x )
    Now use the function cut() to classify the data into four cate-                    The argument breaks can be
gories, and form tables:                                                               either the number of intervals,
                                                                                       or it can be a vector of break
l i b r a r y ( SMIR )
                                                                                       points such that all data val-
data ( bronchit )
                                                                                       ues lie within the range of the
catcig              with ( bronchit ,
                                                                                       breaks. If the smallest of the
                              c u t ( c i g , b r e a k s =c ( 0 , 1 , 1 0 , 3 0 ) ,
                                                                                       break points equals the smallest
                                      i n c l u d e . l o w e s t =TRUE ) )
                                                                                       data value, supply the argument
tab           with ( bronchit , t a b l e ( r , c a t c i g ) )
                                                                                       include.lowest=TRUE.
r o u n d ( a p p l y ( t a b , 2 , p r o p s , elem = 2 ) , 3 )

     [0 ,1]      (1 ,10] (10 ,30]
     0.072        0.281    0.538

    There is a clear increase in the risk of bronchitis with the num-
ber of cigarettes smoked.
    This categorization was purely for purposes of preliminary anal-                   It was at one time common prac-
ysis. Categorization for purposes of analysis is, with the methodol-                   tice to categorize continuous data,
ogy and software that are now available, usually undesirable. Tables                   in order to allow analysis methods
                                                                                       for multi-way tables. There is a
                                                                                       loss of information, which can at
                                                                                       worst be serious.
                                                                              data entry, manipulation and management             81

that are based on categorization can nevertheless be useful in data
exploration.

Conversion between data frames and array-like structures
                                                                                                Tables have the same structure
Use as.data.frame.table() to convert from a table to a data                                     as matrices or (more generally)
frame. This can also be called with an array argument. Additionally,                            multi-way arrays.
note the generic function as.data.frame(). For tables, this has the
same result as as.data.frame.table(). For arrays, the two func-
tions give dierent results. The following illistrates the dierence:
    First, create a matrix object that holds the data:
dream
    m a t r i x ( c ( 5 , 3 , 1 7 , 8 5 ) , n c o l =2 ,
                  dimnames= l i s t ( " Dreamer moves "=c ( " Yes " , "No" ) ,
                                            " O b j e c t moves "=c ( " Yes " , "No" ) ) )
dream

              Object moves
Dreamer moves Yes No
          Yes    5 17
          No     3 85

      Now compare:
Matrix to Dataframe                   Table to Dataframe
a s . d a t a . f r a m e ( dream )   a s . d a t a . f r a m e ( a s . t a b l e ( dream ) )

       Yes No                            Dreamer .moves Object .moves Freq
Yes      5 17                         1             Yes
No       3 85                         Yes      5
                                      2              No
                                      Yes      3
                                      3             Yes
                                      No    17
                                      4              No
                                      No    85

    For conversion from a multi-way table to a data frame, consider                             The code on the help page for
the data set UCBAdmissions. Data are admission frequencies, by                                  UCBAdmissions uses apply()
sex, for the six largest departments at the University of California at                         (see Section ??) to give tabu-
                                                                                                lar summaries of the data, and
Berkeley in 1973. For a reference to a web page that has the details;
                                                                                                mosaicplot() to give graphical
see the belp page for UCBAdmissions. Type                                                       summaries of the data.
h e l p ( UCBAdmissions )                # Get details of the data
e x a m p l e ( UCBAdmissions )
      Note the margins of the table:
s t r ( UCBAdmissions )

 table [1:2 , 1:2 , 1:6] 512 313 89 19 353 207 17 8 120 205 ...
 - attr (*, " dimnames ")= List of 3
82    data analysis, graphics, and visualisation using r

     ..$ Admit : chr [1:2] " Admitted " " Rejected "
     ..$ Gender : chr [1:2] "Male" " Female "
     ..$ Dept : chr [1:6] "A" "B" "C" "D" ...

    The following uses the function as.data.frame.table() to
convert the 3-way table UCBAdmissions into a data frame in which         As UCBAdmissions is
the margins are columns:                                                 a table (not an array),
                                                                         as.data.frame(UCBAdmissions)
UCBtab          a s . t a b l e ( UCBAdmissions )                        would give the same result.
UCBdf         a s . d a t a . f r a m e . t a b l e ( UCBtab )
h e a d ( UCBdf , 5 )

        Admit Gender Dept Freq
1    Admitted   Male    A 512
2    Rejected   Male    A 313
3    Admitted Female    A   89
4    Rejected Female    A   19
5    Admitted   Male    B 353

     Alternatively, use the function adply() from the plyr package
that is described in Section 7.3. Here the identity() function does
the manipulation, working with all three dimensions of the array:
library ( plyr )
UCBdf         a d p l y ( . d a t a =UCBAdmissions ,
                          .margins =1:3 ,
                          .fun=i d e n t i t y )
h e a d ( UCBdf , 5 )


7.3      Data Summary ­ the plyr and reshape2
         packages
The plyer package has functions that together:

· provide a systematic approach to computations that perform a
  desired operation across one or more dimensions of an array, or
  across one or more columns of a data frame, or across one or more
  elements of a list;

· allow the user to choose whether results will be returned as an
  array, or as a data frame, or as a list.

     There is a separate function for each of the nine possible map-
pings. The first letter of the function name (one of a = array, d =
data frame, l = list) denotes the class of the input object, while the
second letter (the same choice of one of three letters) denotes the
class of output object that is required. This pair of letters is then
followed by ply.
     Here is the choice of functions:
                                                                             data entry, manipulation and management         83

                                           Class of Output Object
                                     a (array) d (data frame) l (list)
      Class of Input Object
                   a (array)         aaply          adply                 alply
             d (data frame)          daply          ddply                 dlply
                      l (list)       laply          ldply                 llply
    First observe how the function adply can be used to change
from a tabular form of representation to a data frame. The dimension
names will become columns in the data frame.

library ( plyr )
dream
    m a t r i x ( c ( 5 , 3 , 1 7 , 8 5 ) , n c o l =2 ,
                  dimnames= l i s t ( " Dreamer moves "=c ( " Yes " , "No" ) ,
                                            " O b j e c t moves "=c ( " Yes " , "No" ) ) )
( dfdream             a d p l y ( dream , 1 : 2 , . f u n = i d e n t i t y ) )

    Dreamer moves Object moves V1
1             Yes          Yes 5
2              No          Yes 3
3             Yes           No 17
4              No           No 85
    To get the table back, do:
d a p l y ( dfdream , 1 : 2 , f u n c t i o n ( d f ) d f [ , 3 ] )

              Object moves
Dreamer moves Yes No
          Yes    5 17
          No     3 85

     The following calculates sums over the first two dimensions of
the table UCBAdmissions:
a a p l y ( UCBAdmissions , 1 : 2 , sum )

          Gender
Admit      Male Female
  Admitted 1198    557
  Rejected 1493   1278

    Here, aaply() behaves exactly like apply().
    The following calculates, for each level of the column trt in the
data frame nswdemo, the number of values of re74 that are zero:
    To calculate the proportion that are zero, for each of control and                       Notice the use of the syntax
treatment and for each of non-black and black, do:                                           .(trt, black) to identify the
                                                                                             columns trt and black. This
l i b r a r y (DAAG, q u i e t l y =TRUE)                                                    is an alternative to c("trt",
d a p l y ( nswdemo , . ( t r t ) ,                                                          "black").
             f u n c t i o n ( d f ) sum ( d f [ , " r e 7 4 " ]==0 , n a . r m=TRUE ) )
84     data analysis, graphics, and visualisation using r


  0   1
195 131

    The function colwise() takes as argument a function that
operates on a columne of data, returning a function that operates
on all nominated columns of a data frame. To get information on the
proportion of zeros for both of the columns re75 and re78, and for
each of non-black and black, do:
d d p l y ( nswdemo , . ( t r t , b l a c k ) ,
            c o l w i s e ( f u n c t i o n ( x ) sum ( x ==0) / l e n g t h ( x ) ,
                            . c o l s = . ( re75 , re78 ) ) )

     trt black   re75    re78
1      0     0 0.3529 0.15294
2      0     1 0.4353 0.34118
3      1     0 0.2542 0.08475
4      1     1 0.4034 0.26050

    Note that colwise() operates on the objects that are returned
by splitting up the data frame nswdemo according to levels of trt
and black. Note the use of ddply(), not daply().

7.3.1      Use of plyr with Word War 1 cricketer data
Data in the data frame cricketer, xracted by John Aggleton (now
at Univ of Cardi), are from records of UK first class cricketers born
1840 ­ 1960. Variables are
-    Year of birth
-    Years of life (as of 1990)
-    1990 status (dead or alive)
-    Cause of death: killed in action / accident / in bed
-    Bowling hand ­ right or left
The following creates a data frame in which the first column has the
year, the second the number of right-handers born in that year, and
the third the number of left-handers born in that year.
l i b r a r y (DAAG)
rtlef           ddply ( c r i c k e t e r , " year " ,
                        f u n c t i o n ( x ) t a b l e ( x$ l e f t ) )
    The data frame is split by values of year. Numbers of left and
right handers are then tabulated.
    From the data frame cricketer, we extract data for cricketers
who were either killed in action in World War 1, or whose birth year
was within the range of years for players who were killed and who
survived through at lest till the final year of World War 1. We first
determine the relevant range of birth years.
                                                                                 data entry, manipulation and management                      85

ww1         subset ( cricketer ,
                        k i a ==1 & ( y e a r + l i f e )% i n% 1 9 1 4 : 1 9 1 8 )
r a n g e (ww1$ y e a r )


[1] 1869 1896

    Note that a cricketer who was born in 1869 would be 45 in 1914,
while a cricketer who was born in 1896 would be 18 in 1914.
    Now get data for all cricketers who were born within this range
of years and who either died in World War 1 or survived past 1918:

l i b r a r y (DAAG)
chooserows                w i t h ( c r i c k e t e r , y e a r%i n % ( 1 8 6 9 : 1 8 9 6 ) & ( ( k i a = = 1 ) | ( y e a r + l i f e ) > 1 9 1 8 ) )
tab           with ( s u b s e t ( c r i c k e t e r , chooserows ) , t a b l e ( year , l e f t , kia ) )
ww1df           a d p l y ( t a b , 1 : 2 , f u n c t i o n ( x ) c ( p r o p= a s . n u m e r i c ( x [ 2 ] ) / sum ( x ) , num=sum ( x ) ) )
ww1df$ y e a r            a s . n u m e r i c ( a s . c h a r a c t e r ( ww1df$ y e a r ) )

For each year of birth between 1869 and 1896, the number of crick-
eters killed in action has been expressed as a fraction of the total
number of cricketers (in action or not) who were born in that year.



7.3.2        melt() acast() & dcast() (reshape2)
This package is designed to facilitate creation of versions of a data
frame in which selected columns are moved from an unstacked to
a stacked version, or vice-versa. In moving from an unstacked to
a stacked version, the column names become levels of a factor. In
the move from stacked to unstacked, factor levels become column
names.
     Here is an example of the use of melt():

## Create dataset Crimean , for use in later calculations
l i b r a r y ( HistData )           # Nightingale is from this package
l i b r a r y ( reshape2 )           # Has the function melt ()
Crimean            melt ( N i g h t i n g a l e [ , c ( 1 , 8 : 1 0 ) ] , " Date " )
names ( Crimean )                c ( " D a t e " , " Cause " , " D e a t h s " )
Crimean $ Cause                f a c t o r ( s u b ( " \ \ . r a t e " , " " , Crimean $ Cause ) )
Crimean $ Regime                 ordered ( rep ( c ( rep ( ' Before ' , 12) ,
                                                 rep ( ' After ' , 12)) , 3) ,
                                                 l e v e l s =c ( ' B e f o r e ' , ' A f t e r ' ) )
formdat            f o r m a t . D a t e ( s o r t ( u n i q u e ( Crimean $ D a t e ) ) ,
                                           f o r m a t ="%d %b %y " )
Crimean $ D a t e           o r d e r e d ( f o r m a t . D a t e ( Crimean $ Date ,
                                             f o r m a t ="%b %y " ) , l e v e l s = f o r m d a t )

The dataset is now in a suitable form for creating a Florence
Nightingale style wedge plot, in Figure 15.3.
86    data analysis, graphics, and visualisation using r

Reshaping World Bank Indicator data for Motion Chart
display
The url http://www.maths.anu.edu.au/~johnm/datasets/
csv/wdiEv.csv has data that was downloaded, for Australia and
China only, for the indicators "Population, total" and "Forest area
(sq. km)", for the two years 2000 and 2012. Subsection 7.5.1 has the
details of how these data were obtained. The following inputs and
displays the data:
url         " h t t p : / / w w w . m a t h s . a n u . e d u . a u / johnm / d a t a s e t s / c s v / "
wdiEx           r e a d . c s v ( paste0 ( url , ' wdiEx.csv ' ) )

  Country .Name Country .Code     Indicator .Name Indicator .Code                                                     X2010
X2000
1     Australia           AUS Labor force , total SL.TLF.TOTL.IN                                               1.171 e+07      9.624 e+06
2     Australia           AUS Population , total     SP.POP.TOTL                                               2.207e+07       1.915 e+07
3         China           CHN Labor force , total SL.TLF.TOTL.IN                                               8.125 e+08      7.234e+08
4         China           CHN Population , total     SP.POP.TOTL                                               1.338 e+09      1.263 e+09

    A googleVis Motion Chart does not make much sense for this
dataset as it stands, with data for just two countries and two years.
Motion charts are desgned for showing how scatterplot relation-
ships, here between forest area and population, have changed over a
number of years. The dataset will however serve for demonstrating
the reshaping that is needed. For input to Motion Charts, we want
indicators to be columns, and years to be rows.
    The melt() and dcast()2 functions from the reshape2 pack-                                       2
                                                                                                     Note also acast(), used if the
age can be used to achieve the desired result. First, create a single                               result wanted is an array or a
column of data, indexed by classifying factors:                                                     matrix.

l i b r a r y ( reshape2 )
wdiLong            m e l t ( wdiEx , i d . v a r s =c ( " Country.Name " ,
                             " Indicator.Name " ) ,
                             m e a s u r e . v a r s =c ( " X2000 " , " X2010 " ) )
## More simply : wdiLong                           melt(wdiEx[, -c (2 ,4)])
wdiLong

     Country .Name            Indicator .Name variable     value
1       Australia         Labor force , total    X2000 9.624e+06
2       Australia          Population , total    X2000 1.915e+07
3            China        Labor force , total    X2000 7.234e+08
4            China         Population , total    X2000 1.263e+09
5       Australia         Labor force , total    X2010 1.171e+07
6       Australia          Population , total    X2010 2.207e+07
7            China        Labor force , total    X2010 8.125e+08
8            China         Population , total    X2010 1.338e+09

o p t i o n s ( w i d t h =54)
    Now use dcast() to "cast" the data frame into a form where the                                  If a matrix or array is required, use
indicator variables are columns:                                                                    acast() in place of dcast().
                                                              data entry, manipulation and management         87

names ( wdiLong ) [ 3 ]          " Year "
wdiData      d c a s t ( wdiLong ,
                         Country.Name+Year  I n d i c a t o r . N a m e ,
                         v a l u e . v a r =" v a l u e " )
wdiData

    Country .Name          Year Labor force , total Population , total
1      Australia          X2000             9624371         1.915e+07
2      Australia          X2010           11714938          2.207e+07
3           China         X2000          723386298          1.263e+09
4           China         X2010          812497658          1.338e+09

o p t i o n s ( w i d t h =54)
    A final step is to replace the factor Year by a variable that has
the values 2000 and 2010.
> wdiData <- within(wdiData, {
     levels(Year) <- substring(levels(Year),2)
     Year <- as.numeric(as.character(Year))
  })
> wdiData
  Country.Name Year Forest area (sq. km) Population, total
1 Australia 2000 1549200 19153000
2 Australia 2010 1493000 22299800
3 China 2000 1770000 1262645000
4 China 2010 2068610 1337825000



7.4       Data       Input from a File
7.4.1      Entry of data using read.table() and scan()
read.table() ­ Errors when reading in data: There are several
aliases for read.table() that have dierent settings for input
defaults. Note in particular read.csv(), for reading in comma
delimited .csv files such as can be output from Excel spreadsheets.
See help(read.table). Non-default option settings can however,
for very large files, severely slow data input.
    When input fails, carefully check the parameter settings3 for the       3
                                                                              For text with embedded single
version of the input command that is in use. It may be necessary to         quotes, set quote = "". For
change the field separators (specify sep), and/or the missing value         text with # embedded; change
character(s) (specify na.strings). Embedded quotes and comment              comment.char suitably.
characters (#; by default anything that follows # on the same line is
ignored.) can be a source of di culty.
    The function count.fields() can be used to determine how
many fields the input function is likely to identify in each record. Al-
ternatively, use read.table() with the argument fill=TRUE, and
carefully check the input data frame. Blank fields will be implicitly
added, as needed, so that all records have an equal number of fields.
88   data analysis, graphics, and visualisation using r

     Recall that

- Character vectors are by default converted into factors. To prevent
  such type conversions, specify stringsAsFactors=FALSE.

- Specify heading=TRUE4 to indicate that the first row of input has                         4
                                                                                              By default, if the first row of the
  column names. Use heading=FALSE to indicate that it holds data.                           file has one less field than later
  [If names are not given, columns have default names V1, V2, . . . .]                      rows, it is taken to be a header
                                                                                            row. Otherwise, it is taken as the
- Use the parameter row.names, then specifying a column number,                             first row of data.
  to specify a column for use to provide row names.

     Where a column that should be numeric is converted to a fac-
tor5 , this is an indication that it has one or more fields that, as num-                   5
                                                                                             For example, a "1" (one) may
bers, would be illegal.                                                                     have been mistyped as an "l"
                                                                                            (ell), or "0" (zero) as "O" (oh).
                                                                                            Or "." may have been used as
*The use of scan() for flexible data input Data records may                                 the missing value symbol, but
for example spread over several rows. There seems no way for                                without modifying the parameter
read.table() to handle this. The function scan() has the nec-                               na.strings to indicate this.
essary flexibility. There may be other reasons for using scan().
With large files, data input can be faster than with read.table().
     The following code demonstrates the use of scan() to read in
the file molclock1.txt. To place this file in your working directory,
attach the DAAG package and type datafile("molclock1").                                     There are two calls to scan(),
                                                                                            each time inputting information
colnam         s c a n ( " m o l c l o c k 1 . t x t " , n l i n e s =1 , what=" " )        from the file molclock.txt. The
molclock            s c a n ( " m o l c l o c k 1 . t x t " , s k i p =1 ,                  first, with nlines=1 and what="",
                               what=c ( l i s t ( " " ) , r e p ( l i s t ( 1 ) , 5 ) ) )   read in the column names. The
molclock            d a t a . f r a m e ( m o l c l o c k , r o w . n a m e s =1)           second call, with the arguments
  # Column 1 supplies row names                                                             skip=1 and what=c(list(""),
names ( m o l c l o c k )          colnam                                                   rep(list(1),5)))], read in the
                                                                                            entries for the several rows of data.
    The what parameter should be a list, with one list element for
each column of input. The "" in the first list element indicates that
the data is to be input as character. The remaining five list elements
hold 1's, indicating numeric data.
    Where records extend over several lines, set multi.line=TRUE.
The length of the what list gives the number of fields in each record.
    Where a number of data files that have the same format, it makes
sense to put the code into a function. The what list can suitably be
an argument to the function.

Large files ­ Reading in part of a file: Di culties with large
files can often be eased by inputting the file in several parts. For
read.table()) use nrows, while for scan() use nlines, to con-
trol the number of lines that will be read. In either case, the argu-
ment skip controls the number of lines to be skipped before data
input starts.
                                                                               data entry, manipulation and management                     89


7.5        Direct       input of raw data from the Internet
Graphs of area-weighted time series of rainfall and temperature
measures, for various regions of Australia, can be accessed from the
Australian Bureau of Meteorology web page http://www.bom.                                          To copy the web address, right
gov.au/cgi-bin/climate/change/timeseries.cgidemo.                                                  click on Raw data set and click
Click on Raw data set to download the raw data.                                                    on Copy Link Location (Firefox)
    The following accesses the latest annual data, for total rainfall                              or Copy Link Address (Google
and average temperature, from the command line:                                                    Chrome) or Copy Link (Safari).

` getbom `
   f u n c t i o n ( s u f f i x =c ( " AVt " , " R a i n " ) , l o c =" e a u s " ) {
       webroot                " h t t p : / / www.bom.gov.au / web01 / n c c /www/ c l i _ c h g / t i m e s e r i e s / "
       midfix               s w i t c h ( s u f f i x [ 1 ] , AVt=" tmean / 0112 / " , R a i n=" r a i n / 0112 / " )
       webpage                p a s t e 0 ( webroot , midfix , loc , " / l a t e s t . t x t " )
       p r i n t ( webpage )
      nam             s w i t c h ( l o c , s e a u s =" s e " , s a u s =" s o u t h " , e a u s =" e a s t " , n a u s=" n o r t h " ,
                                    swaus=" sw " , q l d ="QLD" , nsw="NSW" , n t ="NT" , s a ="SA" ,
                                    t a s ="TAS" , v i c =" VIC " , wa="WA" )
       x          r e a d . t a b l e ( webpage ) $V2
       i f ( s u f f i x [1]% i n%c ( " a v t " , " AVt " ) ) {
           off            s w i t c h ( l o c , s e a u s =14 . 7 2 , s a u s =18 . 5 8 , e a u s =20 . 5 1 , n a u s =24 . 7 1 ,
                                        swaus =16 . 3 , q l d =23 . 2 3 , nsw=17 . 3 3 , n t =25 . 1 7 , s a =19 . 4 5 ,
                                         t a s =10 . 3 5 , v i c =14 . 1 0 , wa=22 . 4 7 )
           x          c ( r e p (NA, 1 0 ) , x+ o f f )
       }
       x
   }
##
## Example of use
seRain              getbom ( s u f f i x =" R a i n " , l o c =" s e a u s " )



7.5.1       Accessing         the World Bank database
A point and click interface will, for most web-based data, be used
to get an initial look at the data. A download mechanism may then
make the data available in a form that can be read straightforwardly
into R. An alternative may be to import the data from the web page
directly into R. Increasinngly, web-based datasets are becoming
available in a form that facilitates such direct importing. The World
Bank database Development Indicators database provides good
examples of some of the alternative means of access.
     The web page http://databank.worldbank.org/data/                                              6
                                                                                                     Click on COUNTRY to modify
home.aspx6 gives a point and click interface to, among other pos-                                  the choice of countries. To expand
sibilities, the World Bank development indicator database. Clicking                                (to 246) countries beyond the
                                                                                                   20 that appear by default, click
on any of 20 country names that are displayed shows data for these
                                                                                                   on Add more country. Click on
countries for 1991-2010, for 54 of the 1262 series that were available                             SERIES and TIME to modify
at last check. Depending on the series, data may be available back                                 and/or expand those choices.
                                                                                                   Click on Apply Changes to set the
                                                                                                   choices in place.
90    data analysis, graphics, and visualisation using r

to 1964. Once selections have been made, click on DOWNLOAD
to download the data. For input into R, downloading as a .csv file is
convenient.
    Manipulations that were required to get these data into a suitable
form for a motion chart display were demonstrated in Subsection
7.3.2


Using the WDI package
The WDI package has the function WDIsearch() that can be used
to search for indicators. To search for indicatord with "CO2" in their
name, enter WDIsearch('co2'). Here are the first 4 (out of 38) that
are given by such a search:
l i b r a r y (WDI)
WDIsearch ( ' co2 ' ) [ 1 : 4 , ]

         indicator
[1,]     "EN.ATM.CO2E.CP.KT"
[2,]     "EN.ATM.CO2E.EG.ZS"
[3,]     "EN.ATM.CO2E.FF.KT"
[4,]     "EN.ATM.CO2E.FF.ZS"
         name
[1,]     "CO2 emissions from cement production ( thousand metric tons )"
[2,]     "CO2 intensity (kg per kg of oil equivalent energy use )"
[3,]     "CO2 emissions from fossil -fuels , total ( thousand metric tons )"
[4,]     "CO2 emissions from fossil -fuels (% of total )"

     The function WDI() can be used to input indicator data, thus:
l i b r a r y (WDI)
inds           c ( ' SP.DYN.TFRT.IN ' , ' SP.DYN.LE00.IN ' , ' SP.POP.TOTL ' ,
   ' NY.GDP.PCAP.CD ' , ' SE.ADT.1524.LT.FE.ZS ' )
indnams              c ( " f e r t i l i t y . r a t e " , " life.expectancy " , " population " ,
                         " G D P . p e r . c a p i t a . C u r r e n t . U S D " , " 15 . t o . 2 5 . y r . f e m a l e . l i t e r a c y " )
names ( i n d s )            indnams
wdiData             WDI( c o u n t r y =" a l l " , i n d i c a t o r = i n d s , s t a r t =1960 , end =2013 , e x t r a =TRUE)
colnum             match ( i n d s , names ( w d i D a t a ) )
names ( w d i D a t a ) [ colnum ]                 indnams
}
## Create a motion chart
WorldBank                d r o p l e v e l s ( s u b s e t ( wdiData , ! r e g i o n %i n% " A g g r e g a t e s " ) )

The eect of extra=TRUE is to include the additional variables
iso2c (2-character country code), country, year, iso3c (3-
character country code), region, capital, longitude, latitude,
income and lending.
    The data frame Worldbank that results is in a form where it
can be used with the googleVIS function gvisMotionChart(, as
described in Section 9.2
                                                                                  data entry, manipulation and management             91

7.5.2        Data     with embedded markup
                                                                                                      Markup Codes: XML, JSON and
The web page http://data.worldbank.org/node/11 gives                                                  JDSONP are among the forms of
technical information needed to set up calls that access the data in                                  markup code that can be embed-
one of the markup formats XML, JSON and JSONP. The markup                                             ded in data that are made available
code is designed to make the file self-describing, so that the user                                   for reading, often from the web.
                                                                                                      Also data, displayed in tabular
does not need to supply details of the data structure to the software
                                                                                                      form on a web page, can be ex-
reading the data.                                                                                     tracted from the HTML markup in
    The folowing code, using the function fromJSON() from the                                         which it is embedded.
RJSONIO package, is due to Markus Gessmann who is author of the
googleVis package:
getWorldBankData                      f u n c t i o n ( i d = ' SP.POP.TOTL ' , d a t e = ' 1 9 6 0 : 2 0 1 0 ' ,
                                                        v a l u e =" v a l u e " , p e r . p a g e =12000){
    r e q u i r e ( RJSONIO )
    url           paste0 ( " http : / / api.worldbank.org / countries / a l l / indicators / " ,
                           i d , " ? d a t e =" , d a t e , "&f o r m a t = j s o n&p e r _ p a g e =" ,
                           per.page )

   wbData    fromJSON ( u r l ) [ [ 2 ] ]
   ## Data is accessed in Javascript Object Notation (JSON)

   wbData = d a t a . f r a m e (
     y e a r = a s . n u m e r i c ( s a p p l y ( wbData , " [ [ " , " d a t e " ) ) ,
     v a l u e = a s . n u m e r i c ( s a p p l y ( wbData , f u n c t i o n ( x )
         i f e l s e ( i s . n u l l ( x [ [ " v a l u e " ] ] ) , NA, x [ [ " v a l u e " ] ] ) ) ) ,
     c o u n t r y . n a m e = s a p p l y ( wbData , f u n c t i o n ( x ) x [ [ " c o u n t r y " ] ] [ ' v a l u e ' ] ) ,
     c o u n t r y . i d = s a p p l y ( wbData , f u n c t i o n ( x ) x [ [ " c o u n t r y " ] ] [ ' i d ' ] )
     )

   names ( wbData ) [ 2 ]                value

  r e t u r n ( wbData )
}
## Obtain data for total population ( SP.POP.TOTL )
wbData           g e t W o r l d B a n k D a t a ( i d =" SP.POP.TOTL " )


Extraction of data from tables in web pages
For web pages that include tables in HTML format, a good way to
access data can be to bring down the web page using readLines(),
then use readHTMLTable() to extract the tables (in character for-
mat) from the input text. The following is an adaptation of what
appears on the help page for readHTMLTable():
l i b r a r y (XML)
u = " h t t p : / / e n . w i k i p e d i a . o r g / wiki / L i s t _ o f _ c o u n t r i e s _ b y _ p o p u l a t i o n "
tables           readHTMLTable ( u )
sapply ( tables , length )

NULL NULL NULL NULL NULL
92    data analysis, graphics, and visualisation using r

      6       2        2          2      2

    The first table, with length 6 (6 columns), is the only table that
has enough columns to hold the data that forms the main part of the
web page. To check that it has the information required, type:
names ( t a b l e s [ [ 1 ] ] )

[1]       "Rank"
[2]       " Country (or dependent territory )"
[3]       " Population "
[4]       "Date"
[5]       "% of world\ npopulation "
[6]       " Source "

    The table that is obtained is a text object. A modest amount
of editing is required to extract the information into a matrix or
data frame that holds the information in numerical form, with row
and column labels attached. The output table can be edited. For an
attempt at more automatic processing, see help(readHTMLTable)
for an example of possible code.

Other data sources
See for example http://www.visualizing.org/data/browse/


7.6        Creating and Using Databases
Note in particular the RSQLite, the RMySQL and the ROracle pack-
ages. These all use the common database interface provided by the
DBI package.
    The RSQLite package makes it possible to create an SQLite
database, or to add new rows to an existing table, or to add new
table(s), within an R session. The SQL query language can then
be used to access tables in the database. Here is an example. First
create the database:

l i b r a r y (DAAG)
l i b r a r y ( RSQLite )
driveLite                 d b D r i v e r ( " SQLite " )
con           d b C o n n e c t ( d r i v e L i t e , dbname=" h i l l r a c e s D B " )
d b W r i t e T a b l e ( con , " h i l l s 2 0 0 0 " , h i l l s 2 0 0 0 ,
                          o v e r w r i t e =TRUE)

[1] TRUE

d b W r i t e T a b l e ( con , " n i h i l l s " , n i h i l l s , o v e r w r i t e =TRUE)

[1] TRUE
                                                               data entry, manipulation and management             93

d b L i s t T a b l e s ( con )

[1] " hills2000 " " nihills "

    The database hillracesDB, if it does not already exist, is cre-
ated in the working directory.
    Now input rows 16 to 20 from the newly created database:
## Get rows 16 to 20 from the newly created nihills DB
dbGetQuery ( con ,
             " s e l e c t * from n i h i l l s l i m i t 5 o f f s e t 15 " )

             row_names dist climb  time timef
1        Slieve Donard 5.5 2790 0.9483 1.2086
2 Flagstaff to Carling 11.0 3000 1.4569 2.0344
3      Slieve Bearnagh 4.0 2690 0.6878 0.7992
4         Seven Sevens 18.9 8775 3.9028 5.9856
5      Lurig Challenge 4.0 1000 0.4347 0.5756

d b D i s c o n n e c t ( con )

[1] TRUE



7.7       Session and Workspace Management
7.7.1      Keep a record of your work
A recommended procedure is to type commands into an editor                       Be sure to save the script file from
window, then sending them across to the command line. This makes                 time to time during the session,
it possible to recover work on those hopefully rare occasions when               and upon quitting the session.
the session aborts.

7.7.2      Workspace management
For tasks that make heavy memory demands, it may be important to
ensure that large data objects do not remain in memory once they are
no longer needed. There are two complementary strategies:
- Objects that cannot easily be reconstructed or copied from else-
  where, but are not for the time being required, are conveniently
  saved to an image file, using the save() function.
- Use a separate working directory for each major project.
     Note the utility function dir() (get the names of files, by de-             Use getwd() to check the name
fault in the current working directory).                                         and path of the current working
     Several image files ("workspaces") that have distinct names can             directory. Use setwd() to change
                                                                                 to a new working directory, while
live in the one working directory. The image file, if any, that is called
                                                                                 leaving the workspace contents
.RData is the file whose contents will be loaded at the beginning of             unchanged.
a new session in the directory.
94    data analysis, graphics, and visualisation using r

The removal of clutter: Use a command of the form rm(x, y,                  As noted in Section 4.2, a good
tmp) to remove objects (here x, y, tmp) that are no longer required.        precaution can be to make an
                                                                            archive of the workspace before
                                                                            such removal.
Movement of files between computers: Files that are saved in the
default binary save file format, as above, can be moved between
dierent computer systems.

Further possibilities ­ saving objects in text form: An alternative to
saving objects7 in an image file is to dump them, in a text format, as      7
                                                                              Dumps of S4 objects and envi-
dump files, e.g.                                                            ronments, amongs others, can-
                                                                            not currently be retrieved using
dump ( c ( " volume " , " w e i g h t " ) , f i l e =" b o o k s . R " )
                                                                            source(). See help(dump).
     The objects can be recreated 8 from this "dump" file by inputting      8
                                                                              The same checks are performed
the lines of books.R one by one at the command line. This is what,          on dump files as if the text had
eectively, the command source() does.                                       been entered at the command line.
                                                                            These can slow down entry of the
source ( " books.R " )                                                      data or other object. Checks on
    For long-term archival storage, dump (.R) files may be prefer-          dependencies can be a problem.
able to image files. For added security, retain a printed version. If a     These can usually be resolved by
                                                                            editing the R source file to change
problem arises (from a system change, or because the file has been
                                                                            or remove oending code.
corrupted), it is then possible to check through the file line by line to
find what is wrong.


7.8      Computer Intensive Computations
Computations may be computer intensive because of the size of
datasets. Or heavy computation may be required even for data sets
that are of modest size.
     Note that using all of the data for an analysis or for a plot is
not always the optimal strategy. There may be insights that are not
otherwise available from running calculations separately on dierent
subsets, perhaps random subsets, of the data.
     Computation will be slow where computationally intensive
calculations are implemented directly in R code, rather than passed
to e cient compiled code that is called from R. Matrix calculations
are passed to highly e cient compiled code. The computationally
intensive part of regression calculations with lm() are handled using
matrices, making these calculations highly e cient.
     Where it is necessary to look for ways to speed up computa-            The relatively new Julia language
tions, it is important to profile computations to find which parts of       appears to oer spectacular im-
the code are taking the major time. Really big improvements will            provements on both R and Python,
                                                                            with times that are within a factor
come from implementing key parts of the calculation in C or Fortran
                                                                            of 2 of the Fortran or C times. See
rather than in an application oriented language such as R or Python.        http://julialang.org/.
Python may do somewhat better than R.
     There can be big dierences between the alternatives that may
be available in R for handling a calculation. Some broad guidelines
                                                                                 data entry, manipulation and management        95

will now be provided, with examples of how dierences in the han-
dling of calculations can aect timings.

Use matrices, where possible, in preference to data frames: Most                              Biological expression array appli-
of R's modeling functions (regression, smoothing, discriminant                                cations are among those that are
analysis, etc.) are designed to work with data frames. Where an                               commonly designed to work with
                                                                                              data that is in a matrix format. The
alternative available that works with matrices, this will be faster.
                                                                                              matrix or matrices may be com-
     Matrix operations can be more e cient even for such a simple                             ponents of a more complex data
operation as adding a constant quantity to each element of the array,                         structure.
or taking logarithms of all elements. Here is an example:
xy       m a t r i x ( rnorm ( 5 * 10 ^ 7 ) , n c o l =100)
dim ( xy )

[1] 500000                 100
                                                                                              Timings are on a mid 2012 1.8
s y s t e m . t i m e ( xy +1)                                                                Ghz Intel i5 Macbook Air laptop
                                                                                              with 8 gigabytes of random access
    user         system elapsed                                                               memory.
   0.114          0.110   0.224

xy.df              d a t a . f r a m e ( xy )
s y s t e m . t i m e ( x y . d f +1)

    user         system elapsed
   1.166          1.375   2.542

Use e cient coding: Matrix arithmetic can be faster than the
equivalent computations that use apply(). Here are timings for
some alternatives that find the sums of rows of the matrix xy above:
                                                 user     system       elapsed
               apply(xy,1,sum)                  0.528      0.087         0.617
             xy %*% rep(1,100)                  0.019      0.001         0.019
                   rowSums(xy)                  0.034      0.001         0.035

The bigmemory project: For details, go to http://www.
bigmemory.org/. The bigmemory package for R "supports the cre-
ation, storage, access, and manipulation of massive matrices". Note
also the associated packages biganalytics, bigtabulate, synchronicity,
and bigalgebra.

The data.table package: This allows the creation of data.table                                On 64-bit systems, massive data
objects from which information can be quickly extracted, often in                             sets, e.g., with tens or hundreds of
a fraction of the time required for extracting the same information                           millions of rows, are possible. For
                                                                                              such large data objects, the time
from a data frame. The package has an accompanying vignette. To
                                                                                              saving can be huge.
display it (assuming that the package has been installed), type
v i g n e t t e ( " d a t a t a b l e i n t r o " , p a c k a g e=" d a t a . t a b l e " )
96     data analysis, graphics, and visualisation using r

File compression: The functions for data input in versions 2.10.0           Note also the R functions
and later of R are able to accept certain types of compressed files.        gzfile() and xzfile() that
This extends scan() and to functions, such as read.maimages()               can be used to create files in a
                                                                            compressed text format. This
in the limma package, that use the standard R data input functions.
                                                                            might for example be text that has
        By way of illustration, consider the ".spot" files coral551.spot,   been input using readLines().
. . . , coral556.spot that are in the subdirectory doc of the DAAGbio
package. In a directory that held the uncompressed files, they were
created by typing, on a Unix or Unix-like command line:                     Severer compression: replace
                                                                              gzip -9 by
gzip       9 coral55 ? .spot
                                                                              xz -9e.
     This created .zip files that were then renamed back to *.spot
files.
     When saving large objects in image format, specify
compress=TRUE. Alternatives that may lead to more compact files
are compress="bzip2" and compress="xz".


7.9       Summary
     apply(), and sapply() can be useful for manipulations with
     data frames and matrices. Note also the functions melt(),
     dcast() and acast() from the reshape2 package.

     scan() can be a useful alternative to read.table() when large
     data sets are input, or when row spreads over more than one line
     of the file.
     Specific action may be needed, when some numbers are zero or
     negative, to avoid problems when taking logarithms

     Careful workspace management is important when files are large.
     It pays to use separate working directories for each dierent
     project, and to save important data objects as image files when
     they are, for the time being, no longer required.

     In computations with large datasets, operations that are formally
     equivalent can dier greatly in their use of computational re-
     sources.
